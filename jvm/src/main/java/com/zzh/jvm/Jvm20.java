package com.zzh.jvm;

/**
 * @Description: 方法区
 * @Author: zzh
 * @Crete 2023/2/2 11:23
 */
public class Jvm20 {
    // 运行时数据区：堆，栈，方法区，程序计数器，本地方法栈
    // 栈堆方法区的交互关系：
    // Person person=new Person();   new Person():存放在堆中，person：存放在栈的局部变量表， Person ：存放在方法区中，类信息
    // 逻辑上，方法区是堆的一部分 ， 方法区可以独立与堆而存在， 非堆，目的就是为了和堆分开
    // 方法区独立与堆的内存空间
    // 线程共享的区域， heapspace， metaspace（PermGen）
    // 方法区：jdk8 使用 元空间代替了永久代， 元空间使用的是本地内存，空间大，不容易发生OOM，永久代使用的是JVM的内存

    /**
     * 方法区的参数设置：
     * jdk7之前： -XX:PermSize 设置永久代的初始大小,默认是20.75M
     * -XX:MaxPermSize 设置永久代的最大可分配空间 ，当类的信息容量超过这个值，就会爆OOM：PermGen
     *
     * jdk8: -XX:MetaspaceSize=21M  默认是21M
     * -XX:MaxMetaspaceSize=21M 默认-1 无限制
     * 为了防止full GC 可以把初始方法区大小MetaspaceSize设置大一些
     *
     * */
    /**
     * 方法区的内部结构：
     * 存放：类信息，运行时常量池，字符串常量（存放在常量池中，但是不同的jdk会有变化），常量，静态变量
     *
     * 类型信息： 对每个加载的类型（类，接口，枚举，注解），jvm中必须有方法区中下列信息：
     * 这个类型的完成有效名称
     * 类型的直接父类的完整有效名
     * 类型的修饰符
     * 类型直接接口的有序列表
     *
     * 域（field）信息：
     *
     * 方法（method）的信息
     *
     * 类加载的时候会记录自己的类加载器
     *  static变量，有没有实例都可以访问
     * static final 全局常量，属性编译的时候就会赋值分配,,,,
     *
     * 运行时常量池：存储着一个一个的步骤，代码运行过程过的每一步操作都在运行时常量池中
     *
     * 数量值，字符串值，类引用，字段引用，方法引用
     *
     * 常量池可以看作是一张表，虚拟机指令根据这张表找到要执行的类名，方法名，参数类型，字面量等类型
     *
     * 运行时常量池，是方法区的一部分，常量池是字节码中的一部分
     *
     *
     *
     * */
    public static void main(String[] args) {



    }
}
