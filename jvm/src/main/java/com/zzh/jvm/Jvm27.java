package com.zzh.jvm;

/**
 * @Description: 垃圾回收相关说明
 * @Author: zzh
 * @Crete 2023/2/7 20:17
 */
public class Jvm27 {

    // 内存溢出，内存泄漏
    // 什么是垃圾？ 垃圾是指在运行的程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
    // 为什么需要GC？
    // 哪些内存需要回收？
    // 什么时候回收？
    // 如何回收？

    /**
     * Java的自动内存管理：
     * 自动的内存分配和回收，当出现问题是我们应该学会定位问题。垃圾回收区域：堆和方法区
     * 频繁收集Young区
     * 较少收集Old区
     * 基本不动方法区（perm MateSpace）
     * */
    /**
     * 垃圾回收的相关算法：
     *  标记阶段：引用计数算法，可达性分析算法（根搜索算法）
     *
     *  清除阶段：标记-清除算法，复制算法，标记-压缩算法
     *
     *  对象的finalization机制，finalization方法
     *  GC Roots的讲解
     *
     *  throw throws:
     *  final finally finalize
     *  自动抛出异常和手动抛出异常
     *
     *  分代收集算法， 增量收集算法，分区算法
     *
     * */
    /**
     *
     * 引用计数算法：保存一个变量，用来保存对象被引用的次数，Java使用的不是引用计数算法
     *
     * 无法解决循环引用的问题（造成内存泄漏问题），
     *
     * Python:如何解决循环引用：手动结束，对象之间的引用关系，  使用弱引用，进行垃圾回收的时候无论内存是否足够，对弱引用都会进行回收
     *
     * */
    /**
     * 可达性分析算法：（根搜索算法，追踪性垃圾收集）
     * 解决引用计数算法中循环引用的问题，方法内存泄漏的发生
     *
     * */
    /**
     * GCRoots: 可达的对象，就是不会被回收的对象
     * GCRoots的常见形式： 虚拟机栈中的引用对象，本地方法栈中的引用对象，方法区中的静态引用对象，方法区中常量引用对象，被同步锁Synchronized持有的对象
     * Java虚拟即的内部引用，
     * */


    /**
     * 对象的finalization机制：
     * 垃圾收集器回收此对象的时候，会调用此对象的finalize()方法
     *
     * 通过finalization机制进行自救：
     *   对象的标记过程至少会经历两次，第一次是GCRoot标记，如果对象和GcRoots没有联系，则会被第一次标记
     *   第二标记，是判断对象是否有存活的可能，如果对象没有发生过finalize() ，则会调用一次，进行自救，如果自救成功，则对象复活（finalize方法只会被调用一次，当再次来到二次标记的过程，次对象不会在执行finalize方法了）
     *
     * 对象的三种状态：
     *    可触及，GcRoots 可以触及的对象会被标记为可触及的对象
     *    可复活，GCroots 不可以触及的对象，但是finalize（）方法可以调用，存在复活的可能
     *    不可触及，GCRoots 不可以触及，切finalize() 已经被调用过一次，没有复活的可能
     * */

    /**
     * MAT 和 JProfiler 的
     * 生成dump文件的方式：
     * jps
     * +
     * jmap -dump:format=b,live,file=test1.bin 1406
     * <p>
     * 生成dump文件，在用MAT( Memory Analyzer)打开 dump 文件，查看堆的信息
     *
     * -Xms8M -Xmx=8M -XX:+HeapDumpOnOutOfMemoryError
     *
     * HeapDumpOnOutOfMemoryError: 当发生堆内存溢出的时候，会生成一个dump文件
     *
     */

    /**
     * 垃圾标记阶段：引用计数算法，可达性分析算法
     *
     * 垃圾清除阶段：标记清除(Mark-Sweep)算法，复制（copying）算法，标记压缩（Mark- Compact）算法
     *没
     * 标记清除(Mark-Sweep)算法:
     * 基础常见的算法，有标记和清除两个阶段：
     * 标记：
     *      垃圾收集器从根结点开始，标记被引用的对象，一般是在对象头中记录为可达
     * 清除：
     *      垃圾收集器对堆内存从头到尾遍历，如果发现对象没有被标记，则进行回收
     *      这里所谓的清除不是真的置空，而是把需要清除的对象地址保存到空闲列表中，下次有新的对象加载时，直接在空闲内存中覆盖
     *
     * 优点：
     * 缺点：效率算法高，在gc的时候需要停止整个应用，导致用户体验差，这种方式清理出来的空闲内存不是连续的，会产生内存碎片，需要维护一个空闲表
     *
     *
     * 复制（copying）算法:
     *
     *  将内存分为两块，垃圾回收的时候，将一块中检测存活的对象直接复制到另外一半的内存中，切内存是整理过的，把没有存活的对象直接回收
     *
     * 优点：没有经过标记清除过程，效率高，清理过的内存是连续的空间， 不会出现碎片问题
     * 缺点：占用两倍的内存空间， 对于G1这种拆分成大量的region的Gc，需要维护多个指针（对象的地址变化，引用也需要变化）
     * 对于大量存活的对象，复制算法开销很大（适用与新生代）
     *
     *
     *
     * 标记压缩（Mark- Compact）算法(标记-整理算法):
     *
     * 标记压缩，标记 清除 压缩算法
     *
     *
     * 小结：
     * */

    /**
     * 分代收集算法：
     * 新生代：采用复制算法。 老年代：采用标记清除算法和标记整理算法的混合实现
     *
     * 增量收集算法和分区算法
     *
     * 增量收集算法： 不会一次性处理垃圾， 解决垃圾回收时间长，应用线程会被挂起很久，严重影响用户体验和系统稳定。
     * 增量收集算法，是垃圾收集线程和用户线程交替执行，不会等到垃圾满的时候在去清理
     *
     * 缺点：垃圾回收过程中，间断性的执行了应用程序的代码，所以能减少垃圾回收的时间，但是因为用户线程和垃圾回收线程交替执行，增加了线程切换和上下文切换的消耗，会是的垃圾回收的总体成本提高，造成系统吞吐量下降
     *
     * 分区算法：针对G1垃圾收集器，降低垃圾回收的停顿时间， 将大的区域，切割小的分区，每次只回收其中若干分区，不会影响用户线程
     * */

    public static void main(String[] args) {


    }
}
