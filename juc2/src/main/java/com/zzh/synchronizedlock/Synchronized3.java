package com.zzh.synchronizedlock;

/**
 * @Description: 偏向锁
 * @Author: zzh
 * @Crete 2023/1/9 10:01
 */
public class Synchronized3 {

    //偏向锁： 但线程竞争，修改线程的 对象标记的 几个标记位，偏向线程id，
    //如果没有其他线程竞争，持有偏向锁的线程永远不需要同步
    //synchronized：频繁的用户态到内核态的切换（加锁解锁）
    //当一段同步代码块，一直被一个线程多次访问，由于只有一个线程那么该线程在后续访问便会自动获得锁
    public static void main(String[] args) {
        //偏向锁：总是被一个线程多次访问，就会形成偏向锁
        //如果某个资源类 标记了偏向锁线程id，则当该线程访问的时候，就不需要同步操作，即加锁解锁，相当于没有加锁一样，运行速度非常快

        //锁的偏向线程ID：，再多线程的情况不是每个线程都会操作资源类，锁总是被一个占用他的线程拥有，这个线程就是锁的偏向线程
        // 偏向锁发生竞争的时候才会释放，线程不会主动释放偏向锁


        //试例：当一个资源类设置偏向锁之后，这个线程不会主动释放锁，线程会一直持有锁，当再次尝试获取锁的时候，只需要判断一下 偏向锁标记位
        //是不是当前线程，如果是，就说明当前线程还持有锁，就不需要在 切换到内核态 获取锁，直接进入同步去操作就可以
        // 偏向标记位设置了偏向线程ID的资源类，的锁一直被偏向线程持有

    }
}
